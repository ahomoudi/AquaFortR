[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "AquaFortR: Streamlining Atmospheric Science, Oceanography, Climate, and Water Research with Fortran-accelerated R",
    "section": "",
    "text": "Preface\nWelcome to the enlightening journey through the pages of “AquaFortR: Streamlining Atmospheric Science, Oceanography, Climate, and Water Research with Fortran-accelerated R”. It is an educational book aimed, in general, at R programmers who want to increase the performance of their codes using Fortran, particularly for bachelor’s, master’s, and PhD students and researchers in the fields mentioned above. Typically, simulation and modelling of the environmental processes are accomplished on the grid level in which the investigation region is discretised to numerous grid points in time and space. Consequently, these simulations produce enormous data sets and processing this data extends beyond the current average personal computer capacity. Nevertheless, a few have access to high-performance computing infrastructures. The possibility of speeding up calculations and modelling exists in each PC through compiled programming languages such as Fortran. This solution speeds up computations and can reduce the CO2 emissions drastically. Fortran is well-suited for numerical and scientific computations due to its array processing capabilities, performance, and efficiency. Combining R with Fortran, data can be smoothly wrangled and visualised. In this book, you will gain invaluable insights into seamlessly speeding up R scripts by harnessing the power of Fortran. You will acquire essential perspectives into speeding up your package using simple Fortran codes. Furthermore, you will accumulate tweaks to accelerate your scripts or packages, and supplementary reading will prove to be both advantageous and highly beneficial for further optimisation and efficiency.",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "index.html#funding",
    "href": "index.html#funding",
    "title": "AquaFortR: Streamlining Atmospheric Science, Oceanography, Climate, and Water Research with Fortran-accelerated R",
    "section": "Funding",
    "text": "Funding\nThis work has been funded by the German Research Foundation (DFG) through the project NFDI4Earth (DFG project no. 460036893, https://www.nfdi4earth.de/) within the German National Research Data Infrastructure (NFDI, https://www.nfdi.de/).",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "index.html#acknowledgement",
    "href": "index.html#acknowledgement",
    "title": "AquaFortR: Streamlining Atmospheric Science, Oceanography, Climate, and Water Research with Fortran-accelerated R",
    "section": "Acknowledgement",
    "text": "Acknowledgement\nAppreciation is extended to Dr. Klemens Barfus for providing invaluable Fortran routines to estimate CAPE.",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "index.html#license",
    "href": "index.html#license",
    "title": "AquaFortR: Streamlining Atmospheric Science, Oceanography, Climate, and Water Research with Fortran-accelerated R",
    "section": "License",
    "text": "License\nThis book is licensed under the Creative Commons Attribution-NonCommercial 4.0 International (CC BY-NC 4.0) License (https://creativecommons.org/licenses/by-nc/4.0/).",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "intro.html",
    "href": "intro.html",
    "title": "1  Introduction",
    "section": "",
    "text": "1.1 R\nR is a powerful and versatile open-source language and environment for statistical computing and graphics (R Core Team, 2023). R was developed to facilitate data manipulation, exploration, and visualisation, providing various statistical and graphical tools.\nThe R environment is designed for effective data handling, array and matrix operations, and is a well-developed and simple programming language (R Core Team, 2023). Its syntax is concise and expressive, making it an accessible language for newbies and seasoned programmers. R can perform tasks either by executing scripts or interactively. The latter is advantageous for beginners and during the first stages of script development. The interactive environment is accessible through command lines or various integrated development environments (IDEs), such RStudio.\nMany factors play an important role in the popularity of R. For example, the ability to produce graphics with a publication’s quality. Simultaneously, the users maintain full control over customising the plots according to their preferences and intricate details. Another significant factor is its ability to be extended to meet the user’s demand. The Comprehensive R Archive Network (CRAN) contains an extensive array of libraries and packages to extend R’s functionality for various tasks. With over 20447 available packages (March 2024), the CRAN package repository is a testament to R’s versatility and adaptability.\nTidyverse (Wickham et al., 2019; Wickham, 2023) is the most popular bundle of R packages for data science. It was developed by Hadley Wickham and his team. The common shared design among tidyverse packages increases the consistency across functions and makes each new function or package a little easier to comprehend and utilise (Wickham et al., 2023).\nMany packages have been developed for spatial data analysis to address various challenging tasks. R-spatial provides a rich set of packages for handling spatial or spatiotemporal data. For example, sf (Pebesma, 2018, 2024a; Pebesma & Bivand, 2023) provides simple features access in R, which is a standardized method for encoding spatial vector data. The stars package (Pebesma, 2024b) aims to handle spatiotemporal arrays. Additionally, the terra package (Hijmans, 2024) works with spatial data and has the ability to process large datasets on the disk when loading into memory (RAM) is not feasible.\nFurthermore, research produces a large data sets; therefore, it is essential to store them according to the FAIR principles (Findability, Accessibility, Interoperability, and Reuse of digital assets; Wilkinson et al. (2016)). NetCDF and HDF5 are among the most prominent scientific data formats owing to their numerous capabilities. The ncdf4 package (Pierce, 2023) delivers a high-level R interface to data files written using Unidata’s netCDF library. Additionally, rhdf5 (Fischer et al., 2023) provides an interface between HDF5 and R.\nRegarding the integration of other programming languages, R has diverse interfaces, which are either a fundamental implementation of R or attainable via another R package (Chambers, 2016). The fundamental interfaces are .Call(), .C(), and .Fortran() to C and Fortran. The development of the Rcpp package (Eddelbuettel et al., 2024) has revolutionised seamless access to C++. Python is also accessible using the reticulate package (Ushey et al., 2024). Finally, the Java interface was granted using the rJava package (Urbanek, 2024).\nIn conclusion, R is a valuable tool in the Earth System, as it can effectively tackle multifarious scientific tasks and address numerous outstanding research inquiries.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "intro.html#fortran",
    "href": "intro.html#fortran",
    "title": "1  Introduction",
    "section": "1.2 Fortran",
    "text": "1.2 Fortran\nFortran, short for Formula Translation, is one of the oldest high-level programming languages. It was first developed in the 1950s, and is nonetheless widely used in scientific and engineering applications. Key features of Fortran include its ability to efficiently handle arrays and matrices, making it well-suited for numerical computations. Additionally, Fortran has a simple and straightforward syntax that makes it easy to learn and use, because it is possible to write mathematical formulas almost as they written in mathematical texts (Metcalf et al., 2018).\nFortran has been revised multiple times, with the most recent iteration being Fortran 2023. Another important feature of Fortran is its support for parallel programming, enabling developers to take advantage of multicore processors and high-performance computing architectures.\nThere are frequently numerous good reasons to integrate different programming languages to achieve tasks. Interoperability with C programming language is a feature that was introduced with Fortran 95 (Metcalf et al., 2018). Given that C is widely used for system-level programming, many of the other languages include support for C. Therefore, the C Application Programming Interface (API) can also be used to connect two non-C languages (Chirila & Lohmann, 2014). For instance, in atmospheric modelling, Fortran is used for its high performance and capcity to handle large data sets, while C is utilised for its efficiency and control over memory usage.\nNoteworthy, developing software using Fortran necessitates utilisation of its primitive procedures and developing from scratch. This is because Fortran is not similar to scripting languages (i.e. R) that requires a special environment (Masuda, 2020). However, Fortran is privileged with its persistent backward compatibility, resulting in the usability of countless (legacy) codes written decades ago.\n\nSince R was designed to streamline data analysis and statistics (Wickham, 2015) and Fortran is renowned for its high performance, it makes seance to integrate the two languages. It should be noted that both programming languages present arrays in column-major order, which makes it easier to bridge without causing confusion. Additionally, R is developed using Fortran, C, and R programming languages, and it features .Call and .External() functions that allows users to utilise compiled code from other R packages.\nDespite the development of newer programming languages, Fortran remains a popular choice for many scientists and engineers due to its reliability, efficiency, and ability to handle large amounts of data.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "intro.html#installation",
    "href": "intro.html#installation",
    "title": "1  Introduction",
    "section": "1.3 Installation",
    "text": "1.3 Installation\nR\nInstallation of R differs according to the operating system:\n\nThe webpage here provides information on installing R according to the Linux distribution.\nFor Windows, the executable can be downloaded from here. Additionally, previous releases of R for Windows exit.\nFor macOS, various releases and versions are accessible here.\n\nRStudio\nAs mentioned earlier, RStudio is an IDE for R. Although it is the most prominent, other IDEs exist, such as Jupyter Notebook and Visual Studio Code. In this book, RStudio will be the main IDE. To install Rstudio, visit the posit page to download the suitable installers.\nFortran\nFortran doesn’t require an explicit installation, unlike interpreted languages such as R. The source code would be translated to the machine language using the Fortran compiler, and then it can be executed. Therefore, it is important to make sure that a Fortran compiler, i.e., the GNU Fortran (gfortran) compiler, exists in the working machine.\n\nIn the majority of Linux distributions, the GCC compilers, including gfortran, come pre-installed.\nFor Windows, installing rtools should ensure the existence of gfortran\nFor macOS, binaries for gfortran are available here. Furthermore, more information is available on R for macOS here\n\n\n\n\n\nChambers, F., John M. CRC Press Boca Raton. (2016). Extending r. CRC Press, Taylor & Francis Group. https://www.routledge.com/Extending-R/Chambers/p/book/9781498775717\n\n\nChirila, D. B., & Lohmann, G. (2014). Introduction to modern fortran for the earth system sciences. Springer Berlin Heidelberg. https://doi.org/10.1007/978-3-642-37009-0\n\n\nEddelbuettel, D., Francois, R., Allaire, J., Ushey, K., Kou, Q., Russell, N., Ucar, I., Bates, D., & Chambers, J. (2024). Rcpp: Seamless r and c++ integration. https://www.rcpp.org\n\n\nFischer, B., Smith, M., & Pau, G. (2023). rhdf5: R interface to HDF5. https://doi.org/10.18129/B9.bioc.rhdf5\n\n\nHijmans, R. J. (2024). Terra: Spatial data analysis. https://rspatial.org/\n\n\nMasuda, Y. (2020). Modern fortran tutorial. Introduction. https://masuday.github.io/fortran_tutorial/introduction.html\n\n\nMetcalf, M., Reid, J., & Cohen, M. (2018). Modern Fortran Explained: Incorporating Fortran 2018. Oxford University Press. https://doi.org/10.1093/oso/9780198811893.001.0001\n\n\nPebesma, E. (2018). Simple Features for R: Standardized Support for Spatial Vector Data. The R Journal, 10(1), 439–446. https://doi.org/10.32614/RJ-2018-009\n\n\nPebesma, E. (2024a). Sf: Simple features for r. https://r-spatial.github.io/sf/\n\n\nPebesma, E. (2024b). Stars: Spatiotemporal arrays, raster and vector data cubes. https://r-spatial.github.io/stars/\n\n\nPebesma, E., & Bivand, R. (2023). Spatial Data Science: With applications in R. Chapman and Hall/CRC. https://doi.org/10.1201/9780429459016\n\n\nPierce, D. (2023). ncdf4: Interface to unidata netCDF (version 4 or earlier) format data files. https://cirrus.ucsd.edu/~pierce/ncdf/\n\n\nR Core Team. (2023). R: A language and environment for statistical computing. R Foundation for Statistical Computing. https://www.R-project.org/\n\n\nUrbanek, S. (2024). rJava: Low-level r to java interface. http://www.rforge.net/rJava/\n\n\nUshey, K., Allaire, J., & Tang, Y. (2024). Reticulate: Interface to python. https://rstudio.github.io/reticulate/\n\n\nWickham, H. (2015). Advanced r. CRC Press. https://www.oreilly.com/library/view/advanced-r/9781466586963/\n\n\nWickham, H. (2023). Tidyverse: Easily install and load the tidyverse. https://tidyverse.tidyverse.org\n\n\nWickham, H., Averick, M., Bryan, J., Chang, W., McGowan, L. D., François, R., Grolemund, G., Hayes, A., Henry, L., Hester, J., Kuhn, M., Pedersen, T. L., Miller, E., Bache, S. M., Müller, K., Ooms, J., Robinson, D., Seidel, D. P., Spinu, V., … Yutani, H. (2019). Welcome to the tidyverse. Journal of Open Source Software, 4(43), 1686. https://doi.org/10.21105/joss.01686\n\n\nWickham, H., Çetinkaya-Rundel, M., & Grolemund, G. (2023). R for data science import, tidy, transform, visualize, and model data (2nd edition). O’Reilly Media.\n\n\nWilkinson, M. D., Dumontier, M., Aalbersberg, Ij. J., Appleton, G., Axton, M., Baak, A., Blomberg, N., Boiten, J.-W., da Silva Santos, L. B., Bourne, P. E., Bouwman, J., Brookes, A. J., Clark, T., Crosas, M., Dillo, I., Dumon, O., Edmunds, S., Evelo, C. T., Finkers, R., … Mons, B. (2016). The FAIR Guiding Principles for scientific data management and stewardship. Scientific Data, 3(1), 160018. https://doi.org/10.1038/sdata.2016.18",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "scripts.html",
    "href": "scripts.html",
    "title": "2  Accelerate R Scripts with Fortran",
    "section": "",
    "text": "2.1 2D Coss-Correlation\nIn signal processing, cross-correlation measures similarity between two signals as a function of the displacement of one relative to the other (Wang, 2019). It can deliver information about the time lag between the two signals. 2D cross-correlation is often applied in computer vision for visual tracking. For example, it is used in template matching, feature detection, and motion tracking. 2D cross-correlation also plays an important role in convolutional networks and machine learning.\nIn atmospheric science, oceanography, climate, and water research, 2D cross-correlation can be applied in various ways. For example, it can be used to estimate ocean surface currents (Warren et al., 2016), cloud tracking using satellite imagery (Seelig et al., 2021), and Particle Image Velocimetry (PIV) in fluid dynamics applications (Willert & Gharib, 1991).\nThe 2D cross-correlation of an array \\(F_{(M, N)}\\), and array \\(G_{(P, Q)}\\), can be given as the array \\(CC_{(M+P-1, N+Q-1)}\\) as shown in Equation 2.1.\n\\[\nCC_{(s,t)} = \\sum_{m = 0}^{M-1}\\sum_{n = 0}^{N-1} F_{(m,n)} G_{(m-s, n-t)}\n\\tag{2.1}\\]\nwhere \\(s\\) varies between \\(-(P-1)\\) and \\((M-1)\\) while \\(t\\) varies between \\(-(Q-1)\\) and \\((N-1)\\). \\(F\\) and \\(G \\in R\\).\nNow, let us define the xcorr2D_r function as shown in Listing 2.1. The function receives two matrices or arrays a & b and return the full cross-correlation plane cc.\nListing 2.1: Cross-correlation in R\n\nxcorr2D_r0 &lt;- function(a, b) {\n  # the full CC matrix\n  cc_row &lt;- nrow(a) + nrow(b) - 1\n  cc_col &lt;- ncol(a) + ncol(b) - 1\n  cc &lt;- matrix(1:c(cc_row * cc_col),\n    byrow = FALSE, ncol = cc_col\n  )\n\n  # obtain possible shifts\n  min_row_shift &lt;- -(nrow(b) - 1)\n  max_row_shift &lt;- (nrow(a) - 1)\n  min_col_shift &lt;- -(ncol(b) - 1)\n  max_col_shift &lt;- (ncol(a) - 1)\n\n  # Padded matrix\n  rows_padded &lt;- abs(min_row_shift) +\n    nrow(a) + abs(max_row_shift)\n  cols_padded &lt;- abs(min_col_shift) +\n    ncol(a) + abs(max_col_shift)\n  # a\n  padded_a &lt;- matrix(0,\n    nrow = rows_padded,\n    ncol = cols_padded\n  )\n  padded_a[\n    (abs(min_row_shift) + 1):(abs(min_row_shift) + nrow(a)),\n    (abs(min_col_shift) + 1):(abs(min_col_shift) + ncol(a))\n  ] &lt;- a\n\n  for (icol in 1:cc_col) {\n    for (irow in 1:cc_row) {\n      icc &lt;- irow + ((icol - 1) * cc_row)\n      cols &lt;- (icol):(icol + ncol(b) - 1)\n      rows &lt;- (irow):(irow + nrow(b) - 1)\n      # b\n      padded_b &lt;- array(0,\n        dim = c(rows_padded, cols_padded)\n      )\n      padded_b[rows, cols] &lt;- b\n\n      cc[irow, icol] &lt;- sum(padded_a * padded_b)\n    }\n  }\n\n  return(cc)\n}\nMoving forward, we can define the xcorr2d_f subroutine in Fortran as shown in Listing 2.2. Subroutines are generally the approach for integrating Fortran in R. Function in Fortran return a single value with no option of altering the input arguments, while subroutines have the ability to perform complex tasks while altering input arguments. This proofs to be helpful e.g., in solving equations system.\nAnother imperative point is to define the dimension of the arrays when passing them to Fortran (i.e. explicit-shape arrays). To illustrate, m, n, p, q, k, l are the dimension of input arrays aand b, and the out array cc.\nListing 2.2: Cross-correlation in Fortran\n\nsubroutine xcorr2d_f(m, n, p, q, k, l, a, b, cc)\n   implicit none\n   integer                                :: m, n, p, q, k, l\n   double precision, dimension(m, n)      :: a\n   double precision, dimension(p, q)      :: b\n   double precision, dimension(k, l)      :: cc\n   !     dummy vars\n   integer                               :: min_row_shift, min_col_shift\n   integer                               :: max_row_shift, max_col_shift\n   integer                               :: rows_padded, cols_padded\n   integer                               :: icol, irow, icc, icol2, irow2\n   real, allocatable, dimension(:, :)    :: padded_a, padded_b\n\n   !     obtain possible shfits\n   min_row_shift = -1*(p - 1)\n   max_row_shift = m - 1\n   min_col_shift = -1*(q - 1)\n   max_col_shift = n - 1\n\n   !   Padded arrray\n   rows_padded = abs(min_row_shift) + m + abs(max_row_shift)\n   cols_padded = abs(min_col_shift) + n + abs(max_col_shift)\n   !    A\n   allocate (padded_a(rows_padded, cols_padded))\n   padded_a = 0.0\n   padded_a((abs(min_row_shift) + 1):(abs(min_row_shift) + m), &\n            (abs(min_col_shift) + 1):(abs(min_col_shift) + n)) = a\n\n   !    B\n   allocate (padded_b(rows_padded, cols_padded))\n   padded_b = 0.0\n   do icol = 1, l\n      do irow = 1, k\n         icc = irow + ((icol - 1)*k)\n         icol2 = icol + q - 1\n         irow2 = irow + p - 1\n         padded_b(irow:irow2, icol:icol2) = b\n         cc(irow, icol) = sum(padded_a*padded_b)\n         padded_b = 0.0\n      end do\n   end do\nend subroutine xcorr2d_f\nSince Fortran is a compiled language, we need to save the subroutine in xcorr2D.f90 file and compile it using: R CMD SHLIB xcorr2D.f90.\nAs mentioned earlier, we need to pass the dimension of the arrays to Fortran. Therefore, it would logical to write a wrapping function for Fortran subroutine that provides other input arguments.\nIn the wrapper function (Listing 2.3), we initially require loading the shared object (.so or .dll), which is the compiled Fortran subroutine, as dyn.load(\"path/to/xcorr2D.so\"). Furthermore, it is important to prepare other input variables for Fortran such as the dimensions of the input and output arrays. Imperatively, data types should be approached carefully. Before calling .Fortran(), all storage mode of the variables in R was converted to the appropriate type using either as.double() or as.integer(). If the wrong type is passed, it can result in a hard-to-catch error or unexpected results1.\nListing 2.3: Cross-correlation wrapping function\n\nxcorr2D_f0 &lt;- function(a, b) {\n  # Please adjust the path to your setup.\n  dyn.load(\"AquaFortR_Codes/xcorr2D.so\")\n\n  # the full CC matrix\n  cc_row &lt;- nrow(a) + nrow(b) - 1\n  cc_col &lt;- ncol(a) + ncol(b) - 1\n  cc &lt;- matrix(1:c(cc_row * cc_col), byrow = FALSE, ncol = cc_col)\n\n  cc&lt;- .Fortran(\"xcorr2d_f\",\n    m = as.integer(dim(a)[1]),\n    n = as.integer(dim(a)[2]),\n    p = as.integer(dim(b)[1]),\n    q = as.integer(dim(b)[2]),\n    k = as.integer(cc_row),\n    l = as.integer(cc_row),\n    a = as.double(a),\n    b = as.double(b),\n    cc = as.double(cc)\n  )$cc\n\n  return(cc)\n}\nNow, we can use an example to compare the performance of the two functions. In order to do so, microbenchmark package (Mersmann, 2024) and ggplot2 (Wickham, 2016; Wickham et al., 2024) are required.\nThe obtained benchmarking data allows (mbm) for a quantitative comparison of the computational efficiency between the two methods. By printing “mbm” in the console (print(mbm)) it is evident that Fortran outperforms the R implementation of 2D cross-correlation by a factor of ~10. The significance of leveraging Fortran becomes evident in Figure 2.1.\nCodelibrary(microbenchmark)\nlibrary(ggplot2)\n\nset.seed(72)\n# Assume a\na &lt;- structure(runif(64), dim = c(8L, 8L))\n# Assume b\nb &lt;- structure(runif(64), dim = c(8L, 8L))\nmbm &lt;- microbenchmark(\n  xcorr2D_r0 = xcorr2D_r0(a, b),\n  xcorr2D_f0 = xcorr2D_f0(a, b)\n)\n\nautoplot(mbm) +\n  stat_summary(\n    fun = \"median\",\n    geom = \"crossbar\",\n    width = 0.6,\n    colour = \"red\"\n  )\n\n\n\n\n\n\nFigure 2.1: Performance comparison of 2D Cross-correlation in R and Fortran. Median is shown as red vertical line.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Accelerate R Scripts with Fortran</span>"
    ]
  },
  {
    "objectID": "scripts.html#sec-2Dxcorr",
    "href": "scripts.html#sec-2Dxcorr",
    "title": "2  Accelerate R Scripts with Fortran",
    "section": "",
    "text": "Note\n\n\n\nPlease use the terminal tab in Rstudio or open a new terminal using Alt+Shift+R\n\n\n\n\n\n\n\n\n\n\n\nImportant\n\n\n\nOn Windows, R CMD SHLIB produces dynamic-link library (dll) files. Please adjust the library extension in R functions according to your OS.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Accelerate R Scripts with Fortran</span>"
    ]
  },
  {
    "objectID": "scripts.html#d-convolution",
    "href": "scripts.html#d-convolution",
    "title": "2  Accelerate R Scripts with Fortran",
    "section": "\n2.2 2D Convolution",
    "text": "2.2 2D Convolution\nConvolution and cross-correlation are both operations applied to two dimensional data (e.g., matrix). Cross-correlation involves sliding a kernel (filter) across a matrix, while convolution involves sliding a flipped kernel across an matrix (Draelos, 2019). Most spatial data in earth science are is discretised resulting in large data sets. Sometimes, these data sets include noise which can obscure meaningful patterns and relationships. One of the prominent methods to remove this nose while preserving important features and structures is the Gaussian smoothing filter. Gaussian smoothing is often achieved by convolution where \\(F\\) is the original data, and \\(G\\) is the kernel representing the 2D Gaussian coefficients.\nThe 2D convolution of an array \\(F_{(M, N)}\\), and array \\(G_{(P, Q)}\\), can be given as the array \\(Conv_{(M+P-1, N+Q-1)}\\). \\(hv\\) means that \\(G\\) is flipped.\n\\[\nConv_{(s,t)} = \\sum_{m = 0}^{M-1}\\sum_{n = 0}^{N-1} F_{(m,n)} G_{(m-s, n-t)}^{hv}\n\\tag{2.2}\\]\nwhere \\(s\\) varies between \\(-(P-1)\\) and \\((M-1)\\) while \\(t\\) varies between \\(-(Q-1)\\) and \\((N-1)\\). \\(F\\) and \\(G \\in R\\).\nIndeed, it is possible to flip the second array and utilise the functions from Section 2.1. Nevertheless, our focus is on the comprehensive workflow. Listing 2.4 presents the implementation of convolution in R, whereas Listing 2.5 demonstrates the Fortran version.\n\n\n\nListing 2.4: Convolution in R\n\nconv2D_r0 &lt;- function(a, b) {\n  # the full convolution matrix\n  conv_row &lt;- nrow(a) + nrow(b) - 1\n  conv_col &lt;- ncol(a) + ncol(b) - 1\n  conv &lt;- matrix(1:c(conv_row * conv_col), byrow = FALSE, ncol = conv_col)\n\n  # obtain possible shifts\n  min_row_shift &lt;- -(nrow(b) - 1)\n  max_row_shift &lt;- (nrow(a) - 1)\n  min_col_shift &lt;- -(ncol(b) - 1)\n  max_col_shift &lt;- (ncol(a) - 1)\n\n  # Padded matrix\n  rows_padded &lt;- abs(min_row_shift) + nrow(a) + abs(max_row_shift)\n  cols_padded &lt;- abs(min_col_shift) + ncol(a) + abs(max_col_shift)\n  # a\n  padded_a &lt;- matrix(0, nrow = rows_padded, ncol = cols_padded)\n  padded_a[\n    (abs(min_row_shift) + 1):(abs(min_row_shift) + nrow(a)),\n    (abs(min_col_shift) + 1):(abs(min_col_shift) + ncol(a))\n  ] &lt;- a\n\n  for (icol in 1:conv_col) {\n    for (irow in 1:conv_row) {\n      iconv &lt;- irow + ((icol - 1) * conv_row)\n      cols &lt;- (icol):(icol + ncol(b) - 1)\n      rows &lt;- (irow):(irow + nrow(b) - 1)\n      # b\n      padded_b &lt;- array(0, dim = c(rows_padded, cols_padded))\n      # flip the kernel i.e. b\n      padded_b[rows, cols] &lt;- b[nrow(b):1, ncol(b):1]\n\n      conv[irow, icol] &lt;- sum(padded_a * padded_b)\n    }\n  }\n\n  return(conv)\n}\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nA Gaussian smoothing filter can be applied to an array a using b as the Gaussian kernel or the 2D Gaussian coefficients. However, the convolution and cross-correlation can be optimised using the Fast Fourier Transform (FFT). See Chapter 4.\n\n\n\n\n\nListing 2.5: Convolution in Fortran\n\nsubroutine conv2d_f(m, n, p, q, k, l, a, b, conv)\n   implicit none\n   integer                                :: m, n, p, q, k, l, i, j\n   double precision, dimension(m, n)      :: a\n   double precision, dimension(p, q)      :: b\n   double precision, dimension(k, l)      :: conv\n   !     dummy vars\n   integer                               :: min_row_shift, min_col_shift\n   integer                               :: max_row_shift, max_col_shift\n   integer                               :: rows_padded, cols_padded\n   integer                               :: icol, irow, iconv, icol2, irow2\n   real, allocatable, dimension(:, :)    :: padded_a, padded_b\n\n   !     obtain possible shfits\n   min_row_shift = -1*(p - 1)\n   max_row_shift = m - 1\n   min_col_shift = -1*(q - 1)\n   max_col_shift = n - 1\n\n\n   !   Padded arrray\n   rows_padded = abs(min_row_shift) + m + abs(max_row_shift)\n   cols_padded = abs(min_col_shift) + n + abs(max_col_shift)\n   !    A\n   allocate (padded_a(rows_padded, cols_padded))\n   padded_a = 0.0\n   padded_a((abs(min_row_shift) + 1):(abs(min_row_shift) + m), &\n            (abs(min_col_shift) + 1):(abs(min_col_shift) + n)) = a\n\n   !    B\n   allocate (padded_b(rows_padded, cols_padded))\n   padded_b = 0.0\n   do icol = 1, l\n      do irow = 1, k\n         iconv = irow + ((icol - 1)*k)\n         icol2 = icol + q - 1\n         irow2 = irow + p - 1\n         padded_b(irow:irow2, icol:icol2) = b(p:1:-1,q:1:-1)\n         conv(irow, icol) = sum(padded_a*padded_b)\n         padded_b = 0.0\n      end do\n   end do\nend subroutine conv2d_f\n\n\n\n\nThe gfortran compiler is also capable of creating shared libraries. It allows for easy addition of other flags, such as enabling the generation of the run-time check (-fcheck=all). The code below shows two options for compiling conv2D.f90 by R or the gfortran compiler.\n\nCode# R\nR CMD SHLIB conv2D.f90\n\n# gfortran on Unix-like\ngfortran -shared conv2D.f90 -o conv2D.so\n\n# gfortran on Windows\ngfortran -shared conv2D.f90 -o conv2D.dll\n\n\nIn R wrapper function, .C64() from dotCall64 package (Gerber et al., 2018; Gerber & Mösinger, 2023) will be used instead of .Fortran(). According to Gerber et al. (2018), .C64() transcends other foreign function interfaces in many aspects:\n\nIt supports long vectors.\nThe SIGNATURE argument ensures that the interfaced R objects are of the specified types\nThe INTENT argument helps avoid unnecessary copies of R objects between languages.\n\nIn Listing 2.6, the basic input arguments, such as the dimensions of input and output arrays, are prepared. Afterwards, the SIGNATURE is defined as six integers and three doubles corresponding to the required types in the subroutine. INTENT will ensure that only the conv argument is copied between R and Fortran. This is particularly important when processing large data set, where coping the subroutine arguments extends beyond the available memory (RAM).\n\n\n\nListing 2.6: Convolution wrapping function\n\nconv2D_f0 &lt;- function(a, b) {\n  require(dotCall64)\n  dyn.load(\"AquaFortR_Codes/conv2D.so\")\n\n  m &lt;- nrow(a)\n  n &lt;- ncol(b)\n\n  p &lt;- nrow(b)\n  q &lt;- ncol(b)\n  # the full convolution matrix\n  conv_row &lt;- m + p - 1\n  conv_col &lt;- n + q - 1\n  conv &lt;- matrix(0,\n    ncol = conv_col,\n    nrow = conv_row\n  )\n\n  conv &lt;- .C64(\"conv2d_f\",\n    SIGNATURE = c(\n      rep(\"integer\", 6),\n      rep(\"double\", 3)),\n    INTENT = c(rep(\"r\",8), \"rw\"),\n    m, n, p, q,\n    k = conv_row,\n    l = conv_col,\n    a = a, b = b,\n    conv = conv\n  )$conv\n\n  return(conv)\n}\n\n\n\n\n\nCodelibrary(microbenchmark)\nlibrary(ggplot2)\n\n\nset.seed(72)\n# Assume a\na &lt;- structure(runif(64), dim = c(8L, 8L))\n# Assume b\nb &lt;- structure(runif(64), dim = c(8L, 8L))\nmbm &lt;- microbenchmark(\n  conv2D_r0 = conv2D_r0(a, b),\n  conv2D_f0 = conv2D_f0(a, b)\n)\n\nautoplot(mbm) +\n  stat_summary(\n    fun = \"mean\",\n    geom = \"crossbar\",\n    width = 0.6,\n    colour = \"red\"\n  )\n\n\n\n\n\n\nFigure 2.2: Performance comparison of 2D Convolution in R and Fortran. Median is shown as red vertical line.\n\n\n\n\nSimilar to cross-correlation calculation, the Fortran implementation of convolution outperforms the R one by a factor of ~10. Performing convolution in large data set using R and Fortran is beneficial since it reduce the required computational resources.\n\n\n\n\n\n\nQuestion\n\n\n\nAfter learning about .Fortran() and .C64(), you can use one of the two examples above and compare the performance of the two interfaces using microbenchmark(). Which function is faster?",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Accelerate R Scripts with Fortran</span>"
    ]
  },
  {
    "objectID": "scripts.html#convective-available-potential-energy-cape",
    "href": "scripts.html#convective-available-potential-energy-cape",
    "title": "2  Accelerate R Scripts with Fortran",
    "section": "\n2.3 Convective Available Potential Energy (CAPE)",
    "text": "2.3 Convective Available Potential Energy (CAPE)\n\nAccording to the Glossary of Meteorology, CAPE is “the potential energy of an air parcel due to positive buoyancy, which is a useful tool for forecasting, parameterising, and estimating the potential updraft strength of convective clouds.” CAPE is calculated as follows (Stull, 2016):\n\\[\nCAPE =  R_d \\sum_{p_{LFC}}^{p_{EL}} (T_p - T_v) . ln(\\frac{p_{bottom}}{p_{top}})\n\\tag{2.3}\\]\nwhere \\(R_d\\) is the gas constant for dry air, \\(T_p\\) is the parcel temperature, \\(T_e\\) is the environment temperature, \\(p\\) is pressure, \\(LFC\\) is the Level of Free Convection, and \\(EL\\) is the Equilibrium Level.\nIn a warming climate, CAPE is expected to increase (Chen et al., 2020), which can result in an elevated risk of thunderstorms. It is crucial for humanity to quantify the future risk for proper preparation and mitigation. Typically, thunderstorms are investigated with convective-permitting modelling (CPM) where the horizontal resolution is less than 4km. CPM simulations produce vast amount of data sets, and CAPE estimation at a specific gridpoint and time is an integration along the vertical profile (Equation 2.3).\nGiven the rapid advancements in computing power, it is anticipated that CPM is expected to be performed at finer horizontal and vertical resolution, thereby increasing the complexity of the CAPE estimation. It is essential that the enhancement of computing power is accompanied by responsible management and resource allocation.\nBecause the CAPE calculation scripts are highly complex and lengthy, the necessary codes are only available in the supplementary materials. Additionally, to test the two implementations of CAPE, the AquaFortR package was installed to utilise the example data. See Listing 2.7.\n\n\n\nListing 2.7: CAPE implementation in R and Fortran\n\nif (!require(AquaFortR)) {\n  remotes::install_github(\"AHomoudi/AquaFortR\", subdir = \"RPackage\")\n}\n\nlibrary(AquaFortR)\ndata(\"radiosonde\")\n\nTemperature &lt;- radiosonde$temp + 273.15 # K\nDewpoint &lt;- radiosonde$dpt + 273.15 # K\nPressure &lt;- radiosonde$pressure # hPa\n# Mixing ratio\nMixingRatio &lt;- mixing_ratio_from_dewpoint(Dewpoint, Pressure)\nt_parcel &lt;- Temperature[1]\ndwpt_parcel &lt;- Dewpoint[1]\nmr_parcel &lt;- MixingRatio[1]\n\nsource(\"AquaFortR_Codes/cape_r.R\")\nsource(\"AquaFortR_Codes/cape_f.R\")\n\n\n\n\n\n\n\n\n\n\nImportant\n\n\n\nForemost, the Fortran subroutine need to be complied as shown in previous sections. The path to the shared library cape_f.so in cape_f.R file should be adapted to the correct path.\n\n\nAs mentioned, integration between R and Fortran should be accomplished through subroutines. Nevertheless, some calculations are complex, and using functions or other subroutines is inevitable. In cape.f90, a module containing all the required utilities was written, and then the main subroutine was included. The approach ensures cape_f has access to the module and is simultaneously available to R.\nExploring Figure 2.3, it is evident that the implementation of Fortran is faster than R by a factor of ~28, proofing that integrating Fortran in R is vital for performance and beneficial for the environment.\n\nCodelibrary(microbenchmark)\nlibrary(ggplot2)\n\nmbm &lt;- microbenchmark(\n  cape_r = cape_r0(t_parcel, dwpt_parcel, mr_parcel,\n    Pressure, Temperature, MixingRatio,\n    vtc = TRUE\n  ),\n  cape_f = cape_f0(t_parcel, dwpt_parcel, mr_parcel,\n    Pressure, Temperature, MixingRatio,\n    vtc = TRUE\n  )\n)\n\nautoplot(mbm) +\n  stat_summary(\n    fun = \"mean\",\n    geom = \"crossbar\",\n    width = 0.6,\n    colour = \"red\"\n  )\n\n\n\n\n\n\nFigure 2.3: Performance comparison of CAPE in R and Fortran\n\n\n\n\n\n\n\n\n\n\n\nChen, J., Dai, A., Zhang, Y., & Rasmussen, K. L. (2020). Changes in convective available potential energy and convective inhibition under global warming. Journal of Climate, 33(6), 2025–2050. https://doi.org/10.1175/JCLI-D-19-0461.1\n\n\nDraelos, R. (2019). Convolution vs. Cross-correlation. In Glass Box. https://glassboxmedicine.com/2019/07/26/convolution-vs-cross-correlation/\n\n\nGerber, F., Moesinger, K., & Furrer, R. (2018). dotCall64: An R package providing an efficient interface to compiled C, C++, and Fortran code supporting long vectors. SoftwareX, 7, 217–221. https://doi.org/10.1016/j.softx.2018.06.002\n\n\nGerber, F., & Mösinger, K. (2023). dotCall64: Enhanced foreign function interface supporting long vectors. https://git.math.uzh.ch/reinhard.furrer/dotCall64\n\n\nMersmann, O. (2024). Microbenchmark: Accurate timing functions. https://github.com/joshuaulrich/microbenchmark/\n\n\nSeelig, T., Deneke, H., Quaas, J., & Tesche, M. (2021). Life Cycle of Shallow Marine Cumulus Clouds From Geostationary Satellite Observations. Journal of Geophysical Research: Atmospheres, 126(22). https://doi.org/10.1029/2021JD035577\n\n\nStull, R. (2016). Practical meteorology: An algebra-based survey of atmospheric science. AVP International, University of British Columbia. https://www.eoas.ubc.ca/books/Practical_Meteorology/\n\n\nWang, C. (2019). Kernel learning for visual perception. https://doi.org/10.32657/10220/47835\n\n\nWarren, M. A., Quartly, G. D., Shutler, J. D., Miller, P. I., & Yoshikawa, Y. (2016). Estimation of ocean surface currents from maximum cross correlation applied to GOCI geostationary satellite remote sensing data over the tsushima (korea) straits. Journal of Geophysical Research: Oceans, 121(9), 6993–7009. https://doi.org/https://doi.org/10.1002/2016JC011814\n\n\nWickham, H. (2016). ggplot2: Elegant graphics for data analysis. Springer-Verlag New York. https://ggplot2.tidyverse.org\n\n\nWickham, H., Chang, W., Henry, L., Pedersen, T. L., Takahashi, K., Wilke, C., Woo, K., Yutani, H., Dunnington, D., & van den Brand, T. (2024). ggplot2: Create elegant data visualisations using the grammar of graphics. https://ggplot2.tidyverse.org\n\n\nWillert, C. E., & Gharib, M. (1991). Digital particle image velocimetry. Experiments in Fluids, 10(4), 181–193. https://doi.org/10.1007/BF00190388",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Accelerate R Scripts with Fortran</span>"
    ]
  },
  {
    "objectID": "scripts.html#footnotes",
    "href": "scripts.html#footnotes",
    "title": "2  Accelerate R Scripts with Fortran",
    "section": "",
    "text": "Writing R Extensions, 5.2 Interface functions .C and .Fortran↩︎",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Accelerate R Scripts with Fortran</span>"
    ]
  },
  {
    "objectID": "package.html",
    "href": "package.html",
    "title": "\n3  Accelerate R Packages with Fortran\n",
    "section": "",
    "text": "3.1 Introduction\nA package in R is a bundle of R code, data, and documentation designed to perform a specific task or a set of tasks (Wickham & Bryan, 2023). Packages are the fundamental units of reproducible R code. Packaging has many benefits:\nMany tools are available to facilitate developing R packages, such as devtools, usethis, and testthat. Additionally, RStudio operates as an invaluable companion. To start the development of an R package within RStudio, navigate to File &gt; New Project &gt; New Directory &gt; R Package, and then proceed to create the project. Alternatively, you can use the devtools::create(\"/path/to/package/location/\") or usethis::create_package(\"/path/to/package/location/\") functions.\nBy employing usethis::use_c(), you can easily incorporate the necessary infrastructure to utilise compiled code. It’s vital to ensure that your package is properly licensed. Various license templates are available through usethis, including the Creative Commons (e.g., CC BY 4.0), which can be implemented via usethis::use_ccby_license().\nFigure 3.1 shows a skeleton of a typical R package called foo. R code is placed in the R/ directory, while the compiled code resides in the src/ directory. R provides a standardised method of documenting packages. The DESCRIPTION is generated with the package template and contains essential documentation, including the package’s title, what the package does, the author, and dependencies. Additionally, the SystemRequirements is important in case the package depends on libraries or tools external to R, e.g., FFTW or GNU make.\nThe R documentation files .Rd are stored within the man/ folder. When employing devtools for package development, the .Rd files are automatically modified when the specially formatted “roxgen comments” above R source codes are modified (Wickham & Bryan, 2023). Thus, it is important to run devtools::document() whenever a function is completed. The NAMESPACE file is a fundamental component of a package. It delivers a context for looking up the value of an object associated with a name (Wickham & Bryan, 2023). Typically, it is modified automatically by roygen2 and contains routines such as export to make the package functions visible, import to import all objects from another package’s namespace or importForm to import selected objects, and useDynLib() for packages with compiled code to register routines from DLL.\nThe second edition of the R Packages book by Hadley Wickham and Jennifer Bryan, particularly the chapter “The Whole Game”, offers essential insights and presents a comprehensive overview of creating an R package.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Accelerate R Packages with Fortran</span>"
    ]
  },
  {
    "objectID": "package.html#introduction",
    "href": "package.html#introduction",
    "title": "\n3  Accelerate R Packages with Fortran\n",
    "section": "",
    "text": "It produces packages that are easily downloaded and used.\nIt forces a tidy code and work process.\nIt enables the re-usage of code from and for other projects.\nFiles rapidly multiply when using foreign languages such as C, C++, or Fortran; thus, packaging makes it easier to maintain and manage dependencies and ports.\n\n\n\n\n\n\n\n\nFigure 3.1: R package structure",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Accelerate R Packages with Fortran</span>"
    ]
  },
  {
    "objectID": "package.html#developing-aquafortr",
    "href": "package.html#developing-aquafortr",
    "title": "\n3  Accelerate R Packages with Fortran\n",
    "section": "\n3.2 Developing AquaFortR",
    "text": "3.2 Developing AquaFortR\nIn this section, we will wrap the routines developed in Chapter 2 within an R package. For simplicity, we will focus on implementing 2D cross-correlation here. In the package ecosystem, it is advantageous to avoid the .Fortran interface. The interface is mainly tailored for Fortran 77, predates any support for ‘modern’ Fortran, and carries a significant overhead. Therefore, we will use .Call the modern interface to C/C++.\nThe development consists mainly of three stages:\n\nWriting the Fortran subroutine\nCrafting C functions to interact between R and Fortran\nAnd finally, creating an R function to call the C function.\n\n\n3.2.1 Fortran Subroutine\nThe best approach to organising Fortran code with an R package is to use modules, storing each module in individual files. The intrinsic module iso_c_binding ensures that precisely the same variable type and kind is used in C and Fortran.\nListing 3.1 shows the structure of the Fortran file AquaFortRmodulef.f90. Fortran files can multiply rapidly, and thus, managing module dependencies can be a tedious task. Numbering the files and writing the routines sequentially, such as AquaFortRmodulesf001.f90 to AquaFortRmodulesf00n.f90, can serve as a practical workaround.\n\n\n\nListing 3.1: Fortran file structure\n\nmodule AquaFortRmodule\n   use, intrinsic :: iso_c_binding\n   implicit none\ncontains\n   ! place subroutines and functions\n   ! ...\n   ! ...\n   ! ...\nend module AquaFortRmodule\n\n\n\n\nListing 3.2 shows the subroutine xcorr2d_f. The differences in comparison to the script version in Listing 2.2 are:\n\nThe kind of the variable is defined according to iso_c_binding. Integers are of the c_int kind, while double precision variables are defined as real with the c_double kind.\nTypically, variables are passed to Fortran (C) by reference (value). The value attribute allows passing by value to Fortran.\nUsing bind() facilitates the interoperability of Fortran procedures with C. The binding label is the name by which the C processer recognises the Fortran procedure. The F77_ prefixes in C add a trailing underscore.\n\n\n\n\nListing 3.2: Cross-correlation in Fortran in R package\n\nsubroutine xcorr2d_f(m, n, p, q, k, l, a, b, cc) bind(C, name=\"xcorr2d_f_\")\n  implicit none\n  integer(kind=c_int), intent(in), value                :: m, n, p, q, k, l\n  real(kind=c_double), intent(in), dimension(m, n)      :: a\n  real(kind=c_double), intent(in), dimension(p, q)      :: b\n  real(kind=c_double), intent(out), dimension(k, l)     :: cc\n  !     dummy vars\n  integer(kind=c_int)        :: min_row_shift, min_col_shift\n  integer(kind=c_int)        :: max_row_shift, max_col_shift\n  integer(kind=c_int)        :: rows_padded, cols_padded\n  integer(kind=c_int)        :: icol, irow, icc, icol2, irow2\n  real(kind=c_double), allocatable, dimension(:, :)     :: padded_a, padded_b\n      \n  ! The rest of the subroutine is similar to Listing 2.2 \n  ! or it can be found in src/AquaFortRmodulef.f90\nend subroutine xcorr2d_f\n\n\n\n\n\n3.2.2 C Functions\nNow, we write C functions that communicate between Fortran and R. The R API has many entry points for the C code. To use the public stable API, the header files in Listing 3.3 should be included in the AquaFortRmodulec.c. Additionally, stdlib.h is included for NULL. It is recommended to use R_NO_REMAP so all API functions have the prefix R_ or Rf_.\n\n\n\nListing 3.3: C headers\n\n#define R_NO_REMAP\n#include &lt;R.h&gt;\n#include &lt;Rinternals.h&gt; // Access to \"public\" internal API\n#include &lt;stdlib.h&gt; // for NULL\n\n\n\n\nF77_NAME() is used to declare the Fortran subroutine in C. Note that variables with value attribute should not be pointers, as shown in Listing 3.4.\n\n\n\nListing 3.4: Declaring Fortran routine in C\n\nvoid F77_NAME(xcorr2d_f)(int m, int n, int p, int q, int k, int l, \n                          double *a, double *b, double *cc);\n\n\n\n\nIn Listing 3.5, the c_xcorr2d_f function communicates between R and C, and invoke the declared Fortran subroutine in C. Everything that moves between R and C should be SEXP. Additional variables required by the Fortran subroutine, such as matrix dimensions, are created within the C code. The F77_CALL() macro is to call the Fortran routine, declared by F77_NAME(), from C. The PROTECT and UNPROTECT macros are required to save the result, i.e., ret, from being destroyed during R’s garbage collection. Variables of type double need to be altered to real before being passed to Fortran.\n\n\n\nListing 3.5: Calling Fortran subroutine in C\n\nextern SEXP c_xcorr2d_f(SEXP a, SEXP b)\n{\n    int m = Rf_nrows(a);\n    int n = Rf_ncols(a);\n    //\n    int p = Rf_nrows(b);\n    int q = Rf_ncols(b);\n    //\n    int k = m + p - 1;\n    int l = n + q - 1;\n\n    SEXP ret;\n    PROTECT(ret = Rf_allocMatrix(REALSXP, k, l));\n    F77_CALL(xcorr2d_f)\n    (m, n, p, q, k, l, REAL(a), REAL(b), REAL(ret));\n    UNPROTECT(1);\n    return (ret);\n}\n\n\n\n\nRegistration of native routines for compiled code is achieved in two stages: first, creating an array describing individual routines using R_CallMethodDef; then, actually registering the routines with R using R_registerRoutines, as shown in Listing 3.6. Registration’s benefits include a faster way to find the address of the entry point and a run-time check concerning the number and type of arguments. The R_useDynamicSymbols routine instructs the .Call function to find only registered routines, even when no package is provided, preventing unnecessary delay due to searching.\nFor further information, please refer to Writing R Extension: 5.4 Registering native routines.\n\n\n\nListing 3.6: Registration of native routines\n\nstatic const R_CallMethodDef CallEntries[] = {\n    {\"c_xcorr2d_f\", (DL_FUNC)&c_xcorr2d_f, 2},\n    {\"c_conv2d_f\", (DL_FUNC)&c_conv2d_f, 2},\n    {\"c_cape_f\", (DL_FUNC)&c_cape_f, 7},\n    {NULL, NULL, 0}};\n\nvoid R_init_AquaFortR(DllInfo *dll)\n{\n    R_registerRoutines(dll, NULL, CallEntries, NULL, NULL);\n    R_useDynamicSymbols(dll, FALSE);\n}\n\n\n\n\n\n\n\n\n\n\nImportant\n\n\n\nAll the C code in Section 3.2.2 is stored within the AquaFortRmodulec.c file.\n\n\n\n3.2.3 R Function\nAfter finishing the Fortran subroutine and C functions, we can write the R function, as shown in Listing 3.7. The first few lines contain the roxgen2 documentation for the function. We use the .Call function to invoke the C function c_xcorr2d_f that will invoke a Fortran subroutine xcorr2d_f.\n\n\n\nListing 3.7: Calling C in R\n\n#' @title 2D cross-correlation using Fortran.\n#'\n#' @description  Calculates the 2D cross-correlation\n#'  of two matrices `a` and `b` using compiled Fortran subroutine.\n#'\n#' @param a A matrix (2D array) of values.\n#' @param b A matrix (2D array) of values.\n#' @return A matrix representing the 2D cross-correlation of \n#' the input matrices.\n#' @export\n#' @examples\n#' a &lt;- matrix(c(1, 2, 3, 4), ncol = 2)\n#' b &lt;- matrix(c(5, 6, 7, 8), ncol = 2)\n#' xcorr2D_f(a, b)\n#' @author Ahmed Homoudi\n#' @export\nxcorr2D_f &lt;- function(a, b) {\n  stopifnot(length(dim(a)) == 2 | length(dim(b)) == 2)\n  result &lt;- .Call(\n    c_xcorr2d_f,\n    a,\n    b\n  )\n  return(result)\n}\n\n\n\n\nIt is crucial to add the following line to the package-level documentation (i.e.AquaFortR-package.R file) to load the DLL and define them in the package’s namespace.\n\nCode#' @useDynLib AquaFortR, .registration=TRUE\n\n\nThis is the end of the general workflow for developing an R package with Fortran code using the .Call interface. In the src/ directory, Fortran modules reside in .f90 files, while C routines are found in .c files. Some packages store their C code in an init.c file. All R code should be kept in the R/ directory.\n\n\n3.2.4 System Dependencies\nOccasionally, you develop a package that needs system-dependent configuration or libraries before installation, such as FFTW. An executable is then executed by R CMD INSTALL before any other action is performed to ensure the successful installation of the package. R allows /configure scripts to check for these dependencies. The /configure script can be written manually or using Autoconf.\nAaron Jacobs wrote about “An Autoconf Primer for R Package Authors.” It is a vital tutorial on developing a /configure script for an R package. Furthermore, detailed information concerning configuration and cleanup is available in Writing R extensions, 1.2 Configure-and-cleanup.\nIn case the configure script requires auxiliary files, it is advised that they should be shipped with the R package in the tools directory. Numerous macros are available at the GNU Autoconf Archive.\n\n\n\n\nWickham, H., & Bryan, J. (2023). R packages: Organize, test, document, and share your code. O’Reilly.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Accelerate R Packages with Fortran</span>"
    ]
  },
  {
    "objectID": "summary.html",
    "href": "summary.html",
    "title": "4  Conclusions and Optimization Insights",
    "section": "",
    "text": "AquaFortR is an educational project for students and researchers in Atmospheric Science, Oceanography, Climate, and Water Research. It aims to demonstrate that simple Fortran scripts can meet the demand for accelerating R, especially considering that most data sets in these fields consist of large discretised arrays representing earth system processes.\nFortran is one of the fastest programming languages, and multidimensional arrays are a core part of it. Fortran subprogram calls are based on call by reference. In simpler terms, they directly modify the variables in memory, and no additional space is allocated, saving a lot of memory when dealing with immense arrays.\nWhen integrating Fortran in R scripts, the old .Fortran interface should be avoided. Instead, the dotCall64::.C64 interface should be utilised. It supports long vectors and type 64-bit integers and provides a mechanism to avoid excessive argument copying. Another option to integrate Fortran in R is packaging and employing .Call, the modern C/C++ interface. Packaging is advantageous since it delivers numerous benefits like code tidiness and reusability.\nIntegrating Fortran in R provides access to the Open Multi-Processing (OpenMP), a standardised API for writing shared-memory multi-process applications (i.e. all processors share memory and data). The R package Romp, by Drew Schmidt, presents introductory OpenMP implementation with R for C, C++, F77, and Fortran 2003.\nNowadays, multicore CPUs are easily accessible. With their proliferation, harnessing the capability of parallelism through OpenMP is a practical reality. For example, the performance of CAPE estimation can easily be improved by passing the atmospheric profiles from R to Fortran (i.e. array[latitude, longitude, level, time]) and distributing the calculation among cores, simultaneously exploiting the power of Fortran and parallelism. Moreover, the convolution of precipitation data can be sped up by passing the data to Fortran and sharing the calculation along the time axis among cores.\nCross-correlation and convolution can be optimised by utilising the Fast Fourier Transform (FTT). The computational efficiency originates from the fact that FFT reduces the computation from O[N2] operations to O[Nlog2 N] operations. It is possible to use the FFTW C subroutine library to compute the discrete Fourier transform (DFT) in one or more dimensions, either in Fortran or C. Furthermore, Fortran can directly utilise linear algebra libraries such as BLAS, LAPACK, and LINPACK.\nR is a versatile, growing, and expanding language and environment for statistical computing and graphics. It excels in wrangling data and generating publication-quality visualisations (e.g., ggplot2), making it a standout choice. While it is primarily focused on flexibility and functionality rather than performance, integrating Fortran compiled codes can render substantial speed enhancements.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Conclusions and Optimization Insights</span>"
    ]
  },
  {
    "objectID": "further_reading.html",
    "href": "further_reading.html",
    "title": "5  Further Reading",
    "section": "",
    "text": "Fortran and R – Speed Things Up by Steve Pittard\nThe Need for Speed Part 1: Building an R Package with Fortran (or C) by Avraham Adler\nThe Need for Speed Part 2: C++ vs. Fortran vs. C by Avraham Adler\nThe R Manuals edited by the R Development Core Team\nWriting R Extensions by R Core Team\nR internals by Hadley Wickham\nHow to write your own R package and publish it on CRAN by Cosima Meyer & Dennis Hammerschmidt\nAdvanced R by Hadley Wickham\nModern Fortran Tutorial by Yutaka Masuda\nExtend R with Fortran by Yutaka Masuda\nFortran 90 Tutorial by Stanford University\nFortran Libraries by Fortran Wiki\nFortran Best Practices by Fortran Community\nFortran 90 Reference Card by Michael Goerz.\nHands-On Programming with R by Garrett Grolemund\nr-spatial by Edzer Pebesma, Marius Appel, and Daniel Nüst\nSpatial Data Science: With Applications in R by Edzer Pebesma and Roger Bivand\nR for Data Science (2e) by Hadley Wickham, Mine Çetinkaya-Rundel, and Garrett Grolemund\nIntroduction to Environmental Data Science by Jerry Davis",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Further Reading</span>"
    ]
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "References",
    "section": "",
    "text": "Chambers, F., John M. CRC Press Boca Raton. (2016). Extending\nr. CRC Press, Taylor & Francis Group. https://www.routledge.com/Extending-R/Chambers/p/book/9781498775717\n\n\nChen, J., Dai, A., Zhang, Y., & Rasmussen, K. L. (2020). Changes in\nconvective available potential energy and convective inhibition under\nglobal warming. Journal of Climate, 33(6), 2025–2050.\nhttps://doi.org/10.1175/JCLI-D-19-0461.1\n\n\nChirila, D. B., & Lohmann, G. (2014). Introduction to modern\nfortran for the earth system sciences. Springer Berlin Heidelberg.\nhttps://doi.org/10.1007/978-3-642-37009-0\n\n\nDraelos, R. (2019). Convolution vs. Cross-correlation. In Glass\nBox. https://glassboxmedicine.com/2019/07/26/convolution-vs-cross-correlation/\n\n\nEddelbuettel, D., Francois, R., Allaire, J., Ushey, K., Kou, Q.,\nRussell, N., Ucar, I., Bates, D., & Chambers, J. (2024). Rcpp:\nSeamless r and c++ integration. https://www.rcpp.org\n\n\nFischer, B., Smith, M., & Pau, G. (2023). rhdf5: R interface to\nHDF5. https://doi.org/10.18129/B9.bioc.rhdf5\n\n\nGerber, F., Moesinger, K., & Furrer, R. (2018). dotCall64: An R package providing an\nefficient interface to compiled C, C++, and\nFortran code supporting long vectors. SoftwareX,\n7, 217–221. https://doi.org/10.1016/j.softx.2018.06.002\n\n\nGerber, F., & Mösinger, K. (2023). dotCall64: Enhanced foreign\nfunction interface supporting long vectors. https://git.math.uzh.ch/reinhard.furrer/dotCall64\n\n\nHijmans, R. J. (2024). Terra: Spatial data analysis. https://rspatial.org/\n\n\nMasuda, Y. (2020). Modern fortran tutorial. Introduction. https://masuday.github.io/fortran_tutorial/introduction.html\n\n\nMersmann, O. (2024). Microbenchmark: Accurate timing functions.\nhttps://github.com/joshuaulrich/microbenchmark/\n\n\nMetcalf, M., Reid, J., & Cohen, M. (2018). Modern Fortran\nExplained: Incorporating Fortran 2018. Oxford University\nPress. https://doi.org/10.1093/oso/9780198811893.001.0001\n\n\nPebesma, E. (2018). Simple Features for R:\nStandardized Support for Spatial Vector Data. The R\nJournal, 10(1), 439–446. https://doi.org/10.32614/RJ-2018-009\n\n\nPebesma, E. (2024a). Sf: Simple features for r. https://r-spatial.github.io/sf/\n\n\nPebesma, E. (2024b). Stars: Spatiotemporal arrays, raster and vector\ndata cubes. https://r-spatial.github.io/stars/\n\n\nPebesma, E., & Bivand, R. (2023). Spatial\nData Science: With applications in R. Chapman and\nHall/CRC. https://doi.org/10.1201/9780429459016\n\n\nPierce, D. (2023). ncdf4: Interface to unidata netCDF (version 4 or\nearlier) format data files. https://cirrus.ucsd.edu/~pierce/ncdf/\n\n\nR Core Team. (2023). R: A language and environment for statistical\ncomputing. R Foundation for Statistical Computing. https://www.R-project.org/\n\n\nSeelig, T., Deneke, H., Quaas, J., & Tesche, M. (2021). Life Cycle of Shallow Marine Cumulus Clouds From\nGeostationary Satellite Observations. Journal of Geophysical\nResearch: Atmospheres, 126(22). https://doi.org/10.1029/2021JD035577\n\n\nStull, R. (2016). Practical meteorology: An algebra-based survey of\natmospheric science. AVP International, University of British\nColumbia. https://www.eoas.ubc.ca/books/Practical_Meteorology/\n\n\nUrbanek, S. (2024). rJava: Low-level r to java interface. http://www.rforge.net/rJava/\n\n\nUshey, K., Allaire, J., & Tang, Y. (2024). Reticulate: Interface\nto python. https://rstudio.github.io/reticulate/\n\n\nWang, C. (2019). Kernel learning for visual perception. https://doi.org/10.32657/10220/47835\n\n\nWarren, M. A., Quartly, G. D., Shutler, J. D., Miller, P. I., &\nYoshikawa, Y. (2016). Estimation of ocean surface currents from maximum\ncross correlation applied to GOCI geostationary satellite remote sensing\ndata over the tsushima (korea) straits. Journal of Geophysical\nResearch: Oceans, 121(9), 6993–7009. https://doi.org/https://doi.org/10.1002/2016JC011814\n\n\nWickham, H. (2015). Advanced r. CRC Press. https://www.oreilly.com/library/view/advanced-r/9781466586963/\n\n\nWickham, H. (2016). ggplot2: Elegant graphics for data\nanalysis. Springer-Verlag New York. https://ggplot2.tidyverse.org\n\n\nWickham, H. (2023). Tidyverse: Easily install and load the\ntidyverse. https://tidyverse.tidyverse.org\n\n\nWickham, H., Averick, M., Bryan, J., Chang, W., McGowan, L. D.,\nFrançois, R., Grolemund, G., Hayes, A., Henry, L., Hester, J., Kuhn, M.,\nPedersen, T. L., Miller, E., Bache, S. M., Müller, K., Ooms, J.,\nRobinson, D., Seidel, D. P., Spinu, V., … Yutani, H. (2019). Welcome to\nthe tidyverse. Journal of Open Source\nSoftware, 4(43), 1686. https://doi.org/10.21105/joss.01686\n\n\nWickham, H., & Bryan, J. (2023). R packages: Organize, test,\ndocument, and share your code. O’Reilly.\n\n\nWickham, H., Çetinkaya-Rundel, M., & Grolemund, G. (2023). R for\ndata science import, tidy, transform, visualize, and model data\n(2nd edition). O’Reilly Media.\n\n\nWickham, H., Chang, W., Henry, L., Pedersen, T. L., Takahashi, K.,\nWilke, C., Woo, K., Yutani, H., Dunnington, D., & van den Brand, T.\n(2024). ggplot2: Create elegant data visualisations using the\ngrammar of graphics. https://ggplot2.tidyverse.org\n\n\nWilkinson, M. D., Dumontier, M., Aalbersberg, Ij. J., Appleton, G.,\nAxton, M., Baak, A., Blomberg, N., Boiten, J.-W., da Silva Santos, L.\nB., Bourne, P. E., Bouwman, J., Brookes, A. J., Clark, T., Crosas, M.,\nDillo, I., Dumon, O., Edmunds, S., Evelo, C. T., Finkers, R., … Mons, B.\n(2016). The FAIR Guiding Principles for scientific\ndata management and stewardship. Scientific Data,\n3(1), 160018. https://doi.org/10.1038/sdata.2016.18\n\n\nWillert, C. E., & Gharib, M. (1991). Digital\nparticle image velocimetry. Experiments in Fluids,\n10(4), 181–193. https://doi.org/10.1007/BF00190388",
    "crumbs": [
      "References"
    ]
  }
]